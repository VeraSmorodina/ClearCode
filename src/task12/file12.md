### Задание 12

Код до применения принципов:
```java
public class NumberProcessor {
public List<Integer> numbers = new ArrayList<>(); // 1. Публичное поле класса

    public void addNumber(int number) {
        numbers = new ArrayList<>(numbers); // 2. Создание нового списка на каждом вызове
        numbers.add(number);
    }

    public int findMax() {
        int max = Integer.MIN_VALUE; // 3. Переменная 'max' объявлена вне цикла
        for (int number : numbers) {
            if (number > max) {
                max = number;
            }
        }
        return max;
    }

    public int calculateSum() {
        int sum = 0; // 4. Переменная 'sum' объявлена вне цикла
        for (int number : numbers) {
            sum += number;
        }
        return sum;
    }

    public void printStatistics() {
        System.out.println("Numbers: " + numbers); // 5. Повторный вызов методов внутри цикла вывода
        System.out.println("Max: " + findMax());
        System.out.println("Sum: " + calculateSum());
    }
}
```
Код после применения принципов:
```java
public class NumberProcessor {
// 1. Переменная 'numbers' сделана приватной и финализирована для защиты от изменения извне
private final List<Integer> numbers = new ArrayList<>();

    // 2. Убрано создание нового списка в 'addNumber', чтобы избежать избыточных операций
    public void addNumber(int number) {
        numbers.add(number);
    }

    // 3. Переменная 'max' локализована в методе через использование Stream API
    private int findMax() {
        return numbers.stream().max(Integer::compare).orElse(Integer.MIN_VALUE);
    }

    // 4. Переменная 'sum' локализована в методе через использование Stream API
    private int calculateSum() {
        return numbers.stream().mapToInt(Integer::intValue).sum();
    }

    // 5. Внутренние методы стали приватными, чтобы ограничить их доступность только внутри класса
    public void printStatistics() {
        // 6. Сохранение значений в локальные переменные для уменьшения вызовов методов
        int max = findMax();
        int sum = calculateSum();
        
        // 7. Группировка связанных команд вывода
        System.out.println("Numbers: " + numbers);
        System.out.println("Max: " + max);
        System.out.println("Sum: " + sum);
    }
}
```
Описание внесенных правок:

1

Сделано поле numbers приватным и финализированным:

До: public List<Integer> numbers = new ArrayList<>();

После: private final List<Integer> numbers = new ArrayList<>();

Ограничена область видимости поля, чтобы
его нельзя было изменять извне. Теперь список чисел 
можно изменять только через методы класса.

2

Изменен метод addNumber:

До: Создавался новый список на каждый вызов.

После: Прямое добавление числа в существующий список.

Избегание избыточного создания новых 
объектов.

3

Использование Stream API для нахождения максимума:

До: Переменная max использовалась с явным циклом.

После: Использован метод stream().max(), чтобы переменная max не объявлялась вне цикла.

Уменьшение области видимости переменной и повышение читабельности кода.

4

Использование Stream API для вычисления суммы:

До: Переменная sum использовалась с явным циклом.

После: Использован метод stream().mapToInt().sum().

Уменьшение области видимости переменной и повышение читаемости кода.

5

Сделаны методы findMax и calculateSum приватными:

До: Методы были публичными.

После: Методы стали приватными.

Эти методы используются только внутри класса, поэтому нет необходимости делать их доступными извне.

6

Локализация значений max и sum:

До: Методы вызывались напрямую в printStatistics.

После: Результаты сохраняются в локальные переменные.

Уменьшение количества вызовов методов и уменьшение "окна уязвимости".

7

Группировка связанных команд:

До: Вывод значений был разрозненным.

После: Все связанные команды по выводу информации
сгруппированы.

Уменьшение "окна уязвимости" переменных и улучшение логической структуры.

8

Применение final к переменной numbers:

До: Переменная могла изменяться.

После: Применен модификатор final, чтобы предотвратить изменение ссылки.

Обеспечение иммутабельности ссылки.

9

Упрощение логики добавления чисел:

До: Новый список создавался при каждом добавлении.

После: Изменение происходит в существующем списке.

Снижение избыточных операций, минимизация изменений.

10

Устранение промежуточных переменных в циклах:

До: Использовались циклы для расчета суммы и максимума.

После: Использованы стандартные методы Stream API.

Устранение промежуточных переменных и повышение эффективности.

11

Повышение читабельности за счет методов Stream API:

Стандартные методы делают код более компактным и понятным.

12

Использование orElse для обработки пустых списков:

До: Вручную задавался Integer.MIN_VALUE.

После: Использован метод orElse для обработки случаев, когда список пуст.

Повышение безопасности кода.

13

Оптимизация методов findMax и calculateSum для многопоточности:

Stream API позволяет упростить многопоточную обработку в будущем.

14

Уменьшение объема кода за счет встроенных функций:

Меньше строк кода за счет встроенных функций делает код проще для сопровождения.

15

Обработка данных как неизменяемых внутри метода:

Меньше вероятность, что данные будут изменены извне.

